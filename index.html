<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>AI Cookie Master</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gaegu:wght@400;700&family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #fdf6e3; --wood-color: #c69c6d; --dough-color: #eaddc7;
            --text-color: #654321; --accent-color: #e57373; --white-color: #fff;
            --success-color: #81c784; --error-color: #e57373;
        }
        body {
            font-family: 'Jua', sans-serif; display: flex; justify-content: center; align-items: center;
            flex-direction: column; background-color: var(--bg-color);
            background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
            margin: 0; height: 100vh; overflow: hidden; color: var(--text-color);
        }
        h1 {
            font-family: 'Gaegu', cursive; font-size: 3em; margin-bottom: 15px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        #game-wrapper {
            padding: 20px; background-color: var(--wood-color); border-radius: 25px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2), inset 0 0 15px rgba(0,0,0,0.3);
        }
        #game-container {
            border: 8px solid #a57f54; border-radius: 15px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2); position: relative; cursor: none;
        }
        #gameCanvas { display: block; border-radius: 7px; }
        .ui-grid {
            width: 840px; display: grid; grid-template-columns: 1fr auto 1fr;
            align-items: center; gap: 20px; margin-top: 15px; font-size: 1.2em;
        }
        #stats, #timer { text-align: center; }
        #stats p, #timer p { margin: 5px 0; }
        .controls { text-align: center; }
        .controls button {
            font-family: 'Jua', sans-serif; padding: 8px 18px; font-size: 1em; cursor: pointer;
            border: none; background-color: var(--white-color); color: var(--text-color);
            border-radius: 20px; margin: 0 5px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }
        .controls button:hover { transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0,0,0,0.15); }
        .controls button.active {
            background-color: var(--accent-color); color: var(--white-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); transform: translateY(1px);
        }
        #custom-cursor {
            position: absolute; border: 2px dashed rgba(0, 0, 0, 0.4); border-radius: 50%;
            pointer-events: none; transform: translate(-50%, -50%); transition: all 0.1s ease-out;
        }
        #status-bar {
            margin-top: 15px; display: flex; gap: 20px; align-items: center;
            padding: 5px 15px; background: rgba(255,255,255,0.5); border-radius: 15px;
        }
        .status-light { width: 12px; height: 12px; border-radius: 50%; transition: background-color 0.3s; }
        .status-light.disconnected { background-color: var(--error-color); }
        .status-light.connected { background-color: var(--success-color); }
        #status-text { font-size: 1em; }
    </style>
</head>
<body>
    <h1>AI Cookie Master</h1>
    <div id="game-wrapper">
        <div id="game-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="custom-cursor"></div>
        </div>
    </div>
    <div class="ui-grid">
        <div id="stats">
            <p>완성도: <span id="completion-score">0.0</span>%</p>
            <p>지저분함: <span id="messiness-score">0.0</span>%</p>
        </div>
        <div id="mode-controls" class="controls">
            <button id="mode-user">USER</button>
            <button id="mode-ai">AI</button>
            <button id="mode-training">TRAINING</button>
        </div>
        <div id="timer">
            <p>남은 시간: <span id="time-left">30</span></p>
            <p>최종 점수: <span id="final-score">0</span></p>
        </div>
    </div>
    <div id="status-bar">
        <div id="ws-status-light" class="status-light disconnected"></div>
        <span id="status-text">TRAINING 모드: WebSocket 연결 필요</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script>
        // --- 전역 상태 및 상수 ---
        const GAME_MODES = { USER: 'USER', AI: 'AI', TRAINING: 'TRAINING' };
        let currentGameMode = GAME_MODES.USER;
        let webSocket = null;
        let onnxSession = null;
        let isRoundOver = false;
        let aiActionInterval = null;
        let lastAiAction = 0;

        // --- 유틸리티 함수 ---
        async function processCanvas(canvas, width, height) {
            const offscreen = new OffscreenCanvas(width, height);
            const ctx = offscreen.getContext('2d');
            ctx.drawImage(canvas, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const float32Data = new Float32Array(width * height);
            for (let i = 0; i < data.length / 4; i++) {
                const gray = (data[i * 4] * 0.299 + data[i * 4 + 1] * 0.587 + data[i * 4 + 2] * 0.114) / 255.0;
                float32Data[i] = gray;
            }
            return float32Data;
        }

        // --- 게임 클래스 ---
        class CookieMasterGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                // --- 수정: willReadFrequently 옵션 추가 ---
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.width = this.canvas.width;
                this.height = this.canvas.height;

                this.ui = {
                    completion: document.getElementById('completion-score'),
                    messiness: document.getElementById('messiness-score'),
                    finalScore: document.getElementById('final-score'),
                    timeLeft: document.getElementById('time-left'),
                    cursor: document.getElementById('custom-cursor'),
                };

                this.GAME_TIME = 30;
                this.MAX_STEPS = 500;
                this.brushRadii = { small: 15, medium: 30, large: 50 };
                this.template = { center: { x: 400, y: 300 }, radius: 150 };
                
                // --- 수정: willReadFrequently 옵션 추가 ---
                this.doughCanvas = new OffscreenCanvas(this.width, this.height);
                this.doughCtx = this.doughCanvas.getContext('2d', { willReadFrequently: true });
                this.templateCanvas = new OffscreenCanvas(this.width, this.height);
                this.templateCtx = this.templateCanvas.getContext('2d', { willReadFrequently: true });
                
                this.reset();
            }

            reset() {
                isRoundOver = false;
                this.startTime = Date.now();
                this.currentStep = 0;
                this.lastScore = 0;
                
                this.mousePos = { x: this.width / 2, y: this.height / 2 };
                this.currentBrushSize = 'medium';

                this.doughCtx.clearRect(0, 0, this.width, this.height);
                this.templateCtx.clearRect(0, 0, this.width, this.height);
                
                this.templateCtx.fillStyle = 'rgba(110, 80, 50, 0.25)';
                this.templateCtx.beginPath();
                this.templateCtx.arc(this.template.center.x, this.template.center.y, this.template.radius, 0, Math.PI * 2);
                this.templateCtx.fill();

                this.update();
                console.log("Game Reset!");
            }

            step(action) {
                if (isRoundOver) return;
                
                this.currentStep++;
                const moveDist = 30;

                switch(action) {
                    case 0: // 도우 찍기
                        this.doughCtx.fillStyle = '#eaddc7';
                        this.doughCtx.beginPath();
                        this.doughCtx.arc(this.mousePos.x, this.mousePos.y, this.brushRadii[this.currentBrushSize], 0, Math.PI * 2);
                        this.doughCtx.fill();
                        break;
                    case 1: this.mousePos.y -= moveDist; break; // 위
                    case 2: this.mousePos.y += moveDist; break; // 아래
                    case 3: this.mousePos.x -= moveDist; break; // 왼쪽
                    case 4: this.mousePos.x += moveDist; break; // 오른쪽
                    case 5: this.currentBrushSize = 'small'; break;
                    case 6: this.currentBrushSize = 'medium'; break;
                    case 7: this.currentBrushSize = 'large'; break;
                }

                this.mousePos.x = Math.max(0, Math.min(this.width, this.mousePos.x));
                this.mousePos.y = Math.max(0, Math.min(this.height, this.mousePos.y));
            }

            calculateReward() {
                const currentScore = this.completion - this.messiness;
                const reward = currentScore - this.lastScore;
                this.lastScore = currentScore;
                return reward;
            }

            update() {
                const doughData = this.doughCtx.getImageData(0, 0, this.width, this.height).data;
                const templateData = this.templateCtx.getImageData(0, 0, this.width, this.height).data;
                
                let templateArea = 0, overlapArea = 0, messArea = 0;
                for (let i = 0; i < doughData.length; i += 4) {
                    const isTemplate = templateData[i + 3] > 0;
                    const isDough = doughData[i + 3] > 0;
                    if (isTemplate) {
                        templateArea++;
                        if (isDough) overlapArea++;
                    } else if (isDough) {
                        messArea++;
                    }
                }
                this.completion = templateArea > 0 ? (overlapArea / templateArea) * 100 : 0;
                this.messiness = templateArea > 0 ? (messArea / templateArea) * 100 : 0;
                this.finalScore = this.completion - this.messiness;

                const timeElapsed = (Date.now() - this.startTime) / 1000;
                const timeLeft = Math.max(0, this.GAME_TIME - timeElapsed);

                // UI 업데이트
                this.ui.completion.textContent = this.completion.toFixed(1);
                this.ui.messiness.textContent = this.messiness.toFixed(1);
                this.ui.finalScore.textContent = Math.round(this.finalScore);
                this.ui.timeLeft.textContent = timeLeft.toFixed(1);
                this.ui.cursor.style.left = `${this.mousePos.x}px`;
                this.ui.cursor.style.top = `${this.mousePos.y}px`;
                const cursorSize = this.brushRadii[this.currentBrushSize] * 2;
                this.ui.cursor.style.width = `${cursorSize}px`;
                this.ui.cursor.style.height = `${cursorSize}px`;

                // 렌더링
                this.ctx.fillStyle = '#fdf6e3';
                this.ctx.fillRect(0, 0, this.width, this.height);
                this.ctx.drawImage(this.templateCanvas, 0, 0);
                this.ctx.drawImage(this.doughCanvas, 0, 0);

                // 종료 조건 확인
                const done = timeLeft <= 0 || this.currentStep >= this.MAX_STEPS;
                if (done && !isRoundOver) {
                    isRoundOver = true;
                    console.log(`Round Over. Final Score: ${this.finalScore.toFixed(2)}`);
                    if (currentGameMode !== GAME_MODES.TRAINING) {
                        setTimeout(() => this.reset(), 2000);
                    }
                }
                return done;
            }

            async getObservation() {
                const obsWidth = 84, obsHeight = 84;
                const doughMask = await processCanvas(this.doughCanvas, obsWidth, obsHeight);
                const templateMask = await processCanvas(this.templateCanvas, obsWidth, obsHeight);

                const timeElapsed = (Date.now() - this.startTime) / 1000;
                const normTime = Math.max(0, this.GAME_TIME - timeElapsed) / this.GAME_TIME;
                const brushMap = { small: 0.0, medium: 0.5, large: 1.0 };
                const normBrush = brushMap[this.currentBrushSize];
                const normMouse = [this.mousePos.x / this.width, this.mousePos.y / this.height];

                // --- 수정: 모든 관찰 값을 배열 형태로 통일 ---
                return {
                    dough_mask: Array.from(doughMask),
                    template_mask: Array.from(templateMask),
                    time_left: [normTime],      // 숫자를 배열로 감싸기
                    brush_size: [normBrush],    // 숫자를 배열로 감싸기
                    mouse_pos: normMouse,       // 이미 배열이므로 그대로 둠
                };
            }
        }

        // --- 모드 및 제어 로직 ---
        const game = new CookieMasterGame();
        const statusText = document.getElementById('status-text');
        const wsStatusLight = document.getElementById('ws-status-light');

        function setGameMode(mode) {
            // --- 수정: 모드가 이미 활성화 상태이면 아무것도 하지 않음 ---
            if (currentGameMode === mode && !isRoundOver) return;

            currentGameMode = mode;
            // sessionStorage는 이제 사용하지 않으므로 관련 코드 제거
            console.log(`Mode changed to: ${mode}`);

            document.querySelectorAll('#mode-controls button').forEach(b => b.classList.remove('active'));
            document.getElementById(`mode-${mode.toLowerCase()}`).classList.add('active');

            clearInterval(aiActionInterval);
            aiActionInterval = null;

            // --- 수정: TRAINING 모드일 때만 연결 시도 ---
            if (mode === GAME_MODES.TRAINING) {
                connectWebSocket();
                statusText.textContent = "연결 시도 중...";
            } else {
                if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                    webSocket.close();
                }
                if (mode === GAME_MODES.AI) {
                    if (!onnxSession) {
                        statusText.textContent = "AI 모드: ONNX 모델 로딩 필요";
                        loadOnnxModel().then(success => {
                            if (success) {
                                statusText.textContent = "AI 모드 활성";
                                startAiDecisions();
                            }
                        });
                    } else {
                        statusText.textContent = "AI 모드 활성";
                        startAiDecisions();
                    }
                } else {
                     statusText.textContent = "USER 모드 활성";
                }
            }
            game.reset();
        }

        function startAiDecisions() {
            if (aiActionInterval) clearInterval(aiActionInterval);
            aiActionInterval = setInterval(async () => {
                if (isRoundOver) return;
                const obs = await game.getObservation();
                const feeds = {
                    "input.1": new ort.Tensor('float32', obs.dough_mask, [1, 1, 84, 84]),
                    "input.4": new ort.Tensor('float32', obs.template_mask, [1, 1, 84, 84]),
                    "input.7": new ort.Tensor('float32', [obs.time_left], [1, 1]),
                    "input.10": new ort.Tensor('float32', [obs.brush_size], [1, 1]),
                    "input.13": new ort.Tensor('float32', obs.mouse_pos, [1, 2])
                };
                const results = await onnxSession.run(feeds);
                lastAiAction = results.output.data[0];
            }, 100); // 100ms 마다 (10 FPS) AI가 결정을 내림
        }

        // --- WebSocket 핸들러 ---
        function connectWebSocket() {
            if (webSocket && (webSocket.readyState === WebSocket.OPEN || webSocket.readyState === WebSocket.CONNECTING)) return;
            webSocket = new WebSocket("ws://localhost:8765");

            webSocket.onopen = () => {
                console.log("WebSocket connection established.");
                // --- 수정: 연결 성공 시 자동으로 TRAINING 모드로 전환 ---
                setGameMode(GAME_MODES.TRAINING);
                statusText.textContent = "TRAINING 모드: 서버에 연결됨";
                wsStatusLight.classList.remove('disconnected');
                wsStatusLight.classList.add('connected');
                // game.reset()은 setGameMode에서 호출되므로 여기서는 제거
            };

            webSocket.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                if (data.command === 'reset') {
                    await resetForTraining();
                } else if (data.command === 'action') {
                    await stepGameForTraining(data.action);
                }
            };

            webSocket.onclose = () => {
                console.log("WebSocket connection closed.");
                statusText.textContent = "TRAINING 모드: 연결 끊김";
                wsStatusLight.classList.remove('connected');
                wsStatusLight.classList.add('disconnected');
                
                // --- 수정: TRAINING 모드였다면 USER 모드로 전환 ---
                if (currentGameMode === GAME_MODES.TRAINING) {
                    setGameMode(GAME_MODES.USER);
                    statusText.textContent = "서버 연결 끊김. USER 모드로 전환됩니다.";
                }
            };

            webSocket.onerror = (error) => {
                console.error("WebSocket error:", error);
                webSocket.close();
            };
        }

        // --- 강화학습용 함수 ---
        async function resetForTraining() {
            game.reset();
            const obs = await game.getObservation();
            const reward = 0;
            const done = false;
            webSocket.send(JSON.stringify({ observation: obs, reward, done }));
        }

        async function stepGameForTraining(action) {
            game.step(action);
            const done = game.update(); // update가 done 상태를 반환하도록 수정됨
            const obs = await game.getObservation();
            const reward = game.calculateReward();
            webSocket.send(JSON.stringify({ observation: obs, reward, done }));
        }

        // --- ONNX 모델 로더 ---
        async function loadOnnxModel() {
            try {
                onnxSession = await ort.InferenceSession.create('./model.onnx');
                console.log("ONNX model loaded successfully.");
                return true;
            } catch (e) {
                console.error(`Failed to load ONNX model: ${e}`);
                statusText.textContent = "AI 모델 로드 실패!";
                return false;
            }
        }

        // --- 메인 게임 루프 및 이벤트 리스너 ---
        function gameLoop() {
            if (!isRoundOver) {
                if (currentGameMode === GAME_MODES.AI) {
                    game.step(lastAiAction);
                }
                game.update();
            }
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('DOMContentLoaded', () => {
            // 모드 버튼 이벤트 리스너
            document.getElementById('mode-user').addEventListener('click', () => setGameMode(GAME_MODES.USER));
            document.getElementById('mode-ai').addEventListener('click', () => setGameMode(GAME_MODES.AI));
            document.getElementById('mode-training').addEventListener('click', () => setGameMode(GAME_MODES.TRAINING));

            // USER 모드 키보드 입력
            document.addEventListener('keydown', (e) => {
                if (currentGameMode !== GAME_MODES.USER || isRoundOver) return;
                let action = -1;
                if (e.key === ' ') action = 0; // Space to stamp
                else if (e.key === 'ArrowUp') action = 1;
                else if (e.key === 'ArrowDown') action = 2;
                else if (e.key === 'ArrowLeft') action = 3;
                else if (e.key === 'ArrowRight') action = 4;
                else if (e.key === '1') action = 5;
                else if (e.key === '2') action = 6;
                else if (e.key === '3') action = 7;
                
                if (action !== -1) {
                    e.preventDefault();
                    game.step(action);
                }
            });

            // --- 수정: sessionStorage 대신, 페이지 로드 시 바로 연결 시도 ---
            setGameMode(GAME_MODES.USER); // 기본 모드로 시작
            connectWebSocket(); // 자동으로 트레이닝 서버 연결 시도

            // 게임 루프 시작
            requestAnimationFrame(gameLoop);
        });
    </script>
</body>
</html>